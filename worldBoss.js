const colors = require('colors');
const WebSocket = require('ws');
const fs = require('fs');
const path = require('path');

// ====== H√†m ph·ª• tr·ª£ c·∫ßn thi·∫øt ======
// prettyBox: copy t·ª´ mongtutien.js ho·∫∑c import n·∫øu d√πng chung
function prettyBox(title, lines, color = 'cyan') {
    const width = Math.max(title.length, ...lines.map(l => l.replace(/\x1b\[[0-9;]*m/g, '').length)) + 4;
    const top = `‚îå${'‚îÄ'.repeat(width-2)}‚îê`;
    const mid = `‚îÇ ${title.padEnd(width-4)} ‚îÇ`;
    const sep = `‚îú${'‚îÄ'.repeat(width-2)}‚î§`;
    const content = lines.map(l => `‚îÇ ${l.padEnd(width-4)} ‚îÇ`).join('\n');
    const bot = `‚îî${'‚îÄ'.repeat(width-2)}‚îò`;
    let box = [top, mid, sep, content, bot].join('\n');
    if (colors[color]) box = colors[color](box);
    return box;
}
// cleanupAndExit: copy t·ª´ mongtutien.js ho·∫∑c import n·∫øu d√πng chung
function cleanupAndExit(exitCode = 1, delay = 3000) {
    // ƒê∆°n gi·∫£n h√≥a cho file ri√™ng l·∫ª
    setTimeout(() => {
        process.exit(exitCode);
    }, delay);
}
// getCookieAutoShared: n·∫øu c·∫ßn, import ho·∫∑c copy v√†o ƒë√¢y
// (b·∫°n c√≥ th·ªÉ b·ªï sung n·∫øu class c·∫ßn d√πng)

// ====== H√†m l·∫•y cookie t·ª± ƒë·ªông t·ª´ file cookie.txt ======
function getCookieFromFile() {
    try {
        const cookieFile = path.join(__dirname, 'cookie1.txt');
        if (fs.existsSync(cookieFile)) {
            const cookie = fs.readFileSync(cookieFile, 'utf8').split(/\r?\n/)[0].trim();
            if (cookie && !cookie.startsWith('#')) {
                console.log('‚úÖ ƒê√£ l·∫•y cookie t·ª´ file cookie.txt!');
                return cookie;
            }
        }
        return null;
    } catch (error) {
        console.log('‚ùå L·ªói khi ƒë·ªçc file cookie.txt:', error.message);
        return null;
    }
}

class WorldBossAutoHunter {
    constructor(cookie, logFn = console.log) {
        this.cookie = cookie;
        this.log = (msg, type = 'info') => {
            const now = new Date();
            const time = now.toLocaleTimeString();
            let icon = '‚ÑπÔ∏è';
            let color = 'cyan';
            if (type === 'success') { icon = 'üü¢'; color = 'green'; }
            else if (type === 'warning') { icon = 'üü°'; color = 'yellow'; }
            else if (type === 'error') { icon = 'üî¥'; color = 'red'; }
            else if (type === 'custom') { icon = '‚ú®'; color = 'magenta'; }
            else if (type === 'attack') { icon = '‚öîÔ∏è'; color = 'blue'; }
            else if (type === 'reward') { icon = 'üèÜ'; color = 'yellow'; }
            else if (type === 'boss') { icon = 'üëπ'; color = 'cyan'; }
            let line = `[${time}] ${icon} ${msg}`;
            if (colors[color]) line = colors[color](line);
            logFn(line);
        };
        this.ws = null;
        this.isRunning = false;
        this.heartbeatInterval = null;
        this.userId = null;
        this.lastLoggedDamageId = null;
        this.rejectedBossIds = new Set();
        this.currentBoss = null;
        this.lastAttackTime = 0;
        this.waitingAttack = false;
        this.bossListTimeout = null;
        this.reconnectTimeout = null;
        this.lastDamage = null;
        this.lastBossId = null;
        this.bossEnded = new Set();
        this.errorCount = 0;
    }
    // --- To√†n b·ªô methods c·ªßa class WorldBossAutoHunter ---
    connect() {
        return new Promise((resolve, reject) => {
            const wsUrl = 'wss://mongtutien.online/ws-boss';
            this.ws = new WebSocket(wsUrl, {
                headers: {
                    'Cookie': `nuxt-session=${this.cookie}`
                }
            });
            this.ws.on('open', () => {
                this.log('[Boss] ƒê√£ k·∫øt n·ªëi WebSocket boss!', 'success');
                this.send({ type: 'boss:list' });
                this.heartbeatInterval = setInterval(() => {
                    this.send({ type: 'ping', data: {} });
                }, 10000);
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }
                resolve();
            });
            this.ws.on('close', (code, reason) => {
                this.log(`[Boss] M·∫•t k·∫øt n·ªëi WebSocket boss! Tool s·∫Ω t·ª± ƒë·ªông t·∫Øt ho√†n to√†n.`, 'error');
                if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
                if (this.bossListTimeout) clearTimeout(this.bossListTimeout);
                if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
                process.exit(1); // Tho√°t ho√†n to√†n, kh√¥ng restart
            });
            this.ws.on('error', (err) => {
                this.log(`[Boss] L·ªói WebSocket boss: ${err.message}. Tool s·∫Ω t·ª± ƒë·ªông t·∫Øt ho√†n to√†n.`, 'error');
                if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
                if (this.bossListTimeout) clearTimeout(this.bossListTimeout);
                if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
                process.exit(1); // Tho√°t ho√†n to√†n, kh√¥ng restart
            });
        });
    }

    send(obj) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(obj));
        }
    }

    async start() {
        this.isRunning = true;
        await this.connect();
        this.ws.on('message', (data) => {
            try {
                const msg = JSON.parse(data);
                this.handleMessage(msg);
            } catch (e) {
                this.log(`[Boss] L·ªói parse message: ${e.message}`, 'error');
            }
        });
        // G·ª≠i boss:list ƒë·ªÅu ƒë·∫∑n m·ªói 11 gi√¢y
        this.autoListInterval = setInterval(() => {
            this.send({ type: 'boss:list' });
        }, 11000);
        // Ki·ªÉm tra k·∫øt n·ªëi sau 30 gi√¢y
        setTimeout(() => {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                this.log(`[Boss] WebSocket kh√¥ng k·∫øt n·ªëi sau 30s, tho√°t tool...`, 'error');
                cleanupAndExit(1, 3000);
            } else {
                this.log(`[Boss] WebSocket k·∫øt n·ªëi ·ªïn ƒë·ªãnh`, 'success');
            }
        }, 30000);
        // Ki·ªÉm tra ho·∫°t ƒë·ªông sau 60 gi√¢y
        setTimeout(() => {
            if (!this.currentBoss && !this.lastAttackTime) {
                this.log(`[Boss] Kh√¥ng c√≥ ho·∫°t ƒë·ªông boss sau 60s, ti·∫øp t·ª•c ch·ªù...`, 'warning');
                setTimeout(() => {
                    this.send({ type: 'boss:list' });
                }, 60000);
            } else {
                this.log(`[Boss] Tool ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng`, 'success');
            }
        }, 60000);
    }

    // Th√™m h√†m c·∫≠p nh·∫≠t currentBoss t·ª´ payload n·∫øu c√≥
    updateCurrentBossFromPayload(payload) {
        if (!payload) return;
        // ∆Øu ti√™n id, name, m√°u
        const id = payload.bossId || payload.id || payload._id;
        const name = payload.bossName || payload.name;
        const currentHp = payload.currentHp || payload.hp;
        const maxHp = payload.maxHp || payload.hp;
        if (id && name) {
            this.currentBoss = {
                id,
                name,
                currentHp,
                maxHp
            };
        }
    }

    async handleMessage(msg) {
        let data = msg;
        if (typeof msg === 'string') {
            try { data = JSON.parse(msg); } catch (e) { return; }
        }
        // X·ª≠ l√Ω l·ªói x√°c th·ª±c
        if (data.error && (data.error.includes('cookie') || data.error.includes('x√°c th·ª±c') || data.error.includes('401'))) {
            this.errorCount++;
            if (this.errorCount > 3) {
                this.log('L·ªói x√°c th·ª±c qu√° nhi·ªÅu l·∫ßn, d·ª´ng ch·ª©c nƒÉng boss th·∫ø gi·ªõi.', 'error');
                if (this.ws) this.ws.close();
                return;
            }
            this.log('L·ªói x√°c th·ª±c, ƒëang l·∫•y l·∫°i cookie...', 'warning');
            // getCookieAutoShared is not defined in this file, so this part is commented out
            // const newCookie = await getCookieAutoShared();
            // if (newCookie) {
            //     this.cookie = newCookie;
            //     this.errorCount = 0;
            //     this.log('ƒê√£ l·∫•y l·∫°i cookie m·ªõi, ti·∫øp t·ª•c...', 'success');
            //     // Reconnect ws
            //     if (this.ws) this.ws.close();
            //     await this.connect();
            // } else {
            //     this.log('Kh√¥ng l·∫•y l·∫°i ƒë∆∞·ª£c cookie m·ªõi.', 'error');
            // }
            return;
        }
        // C·∫≠p nh·∫≠t currentBoss t·ª´ payload n·∫øu c√≥
        if (data.payload) this.updateCurrentBossFromPayload(data.payload);
        // Lu√¥n log dame m·ªói l·∫ßn nh·∫≠n ƒë∆∞·ª£c, ∆∞u ti√™n l·∫•y t√™n boss, m√°u boss t·ª´ payload
        if (data.type === 'boss:attack' && data.payload && data.payload.damage) {
            const damage = data.payload.damage;
            const bossName = data.payload.bossName || (this.currentBoss ? this.currentBoss.name : '');
            const currentHp = data.payload.currentHp || (this.currentBoss ? this.currentBoss.currentHp : undefined);
            const maxHp = data.payload.maxHp || (this.currentBoss ? this.currentBoss.maxHp : undefined);
            // L·ªçc ch·ªâ log dame c·ªßa m√¨nh
            if (damage > 0 && bossName && data.payload.userId && this.userId && data.payload.userId === this.userId) {
                let lines = [];
                lines.push(`‚öîÔ∏è Dame c·ªßa b·∫°n: ${damage.toLocaleString()} | üëπ Boss: ${bossName}`);
                if (typeof currentHp === 'number' && typeof maxHp === 'number')
                    lines.push(`‚ù§Ô∏è HP: ${currentHp.toLocaleString()} / ${maxHp.toLocaleString()}`);
                this.log(prettyBox('World Boss', lines, 'blue'), 'attack');
                this.lastDamage = damage;
            }
        }
        // Khi boss k·∫øt th√∫c, log b·∫£ng x·∫øp h·∫°ng v√† th∆∞·ªüng ƒë·∫πp
        if (data.type === 'boss:end' && data.payload && data.payload.bossId) {
            this.bossEnded.add(data.payload.bossId);
            this.lastDamage = 0;
            this.currentBoss = null;
            // Log b·∫£ng x·∫øp h·∫°ng v√† th∆∞·ªüng
            const ranking = data.payload.ranking || [];
            const reward = data.payload.reward || {};
            let lines = [];
            if (ranking.length > 0) {
                lines.push('üèÖ B·∫£ng x·∫øp h·∫°ng:');
                ranking.slice(0,5).forEach((r, i) => {
                    lines.push(` ${i+1}. ${r.name} - ${r.damage.toLocaleString()} dame`);
                });
            }
            if (reward.honor || reward.spiritStone || reward.equipment || reward.item) {
                lines.push('üèÜ Th∆∞·ªüng:');
                if (reward.honor) lines.push(`  - Honor: ${reward.honor}`);
                if (reward.spiritStone) lines.push(`  - Linh th·∫°ch: ${reward.spiritStone.toLocaleString()}`);
                if (reward.equipment) lines.push(`  - Trang b·ªã: ${reward.equipment}`);
                if (reward.item) lines.push(`  - V·∫≠t ph·∫©m: ${reward.item}`);
            }
            this.log(prettyBox('K·∫øt th√∫c Boss Th·∫ø Gi·ªõi', lines, 'green'), 'reward');
        }
        // X·ª≠ l√Ω message log ƒë·ªÉ t√¨m th√¥ng tin damage (lu√¥n log n·∫øu c√≥ dame)
        if (data.type === 'log' && data.payload && data.payload.text) {
            const text = data.payload.text;
            const damageMatch = text.match(/(\d+(?:,\d+)*) s√°t th∆∞∆°ng/);
            if (damageMatch) {
                const damage = parseInt(damageMatch[1].replace(/,/g, ''));
                const bossName = data.payload.bossName || (this.currentBoss ? this.currentBoss.name : 'Boss');
                const currentHp = data.payload.currentHp || (this.currentBoss ? this.currentBoss.currentHp : undefined);
                const maxHp = data.payload.maxHp || (this.currentBoss ? this.currentBoss.maxHp : undefined);
                if (damage > 0) {
                    if (typeof currentHp === 'number' && typeof maxHp === 'number') {
                        this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName} | HP: ${currentHp.toLocaleString()}/${maxHp.toLocaleString()}`);
                    } else {
                        this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName}`);
                    }
                    this.lastDamage = damage;
                }
            }
        }
        // X·ª≠ l√Ω message warn ƒë·ªÉ t√¨m th√¥ng tin damage (lu√¥n log n·∫øu c√≥ dame)
        if (data.type === 'warn' && data.payload && data.payload.text) {
            const text = data.payload.text;
            const damageMatch = text.match(/(\d+(?:,\d+)*) s√°t th∆∞∆°ng/);
            if (damageMatch) {
                const damage = parseInt(damageMatch[1].replace(/,/g, ''));
                const bossName = data.payload.bossName || (this.currentBoss ? this.currentBoss.name : 'Boss');
                const currentHp = data.payload.currentHp || (this.currentBoss ? this.currentBoss.currentHp : undefined);
                const maxHp = data.payload.maxHp || (this.currentBoss ? this.currentBoss.maxHp : undefined);
                if (damage > 0) {
                    if (typeof currentHp === 'number' && typeof maxHp === 'number') {
                        this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName} | HP: ${currentHp.toLocaleString()}/${maxHp.toLocaleString()}`);
                    } else {
                        this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName}`);
                    }
                    this.lastDamage = damage;
                }
            }
            if (text.includes('ƒë√£ tham gia m·ªôt tr·∫≠n Boss kh√°c r·ªìi')) {
                if (this.currentBoss) {
                    this.log(`[Boss] ‚ö†Ô∏è Boss "${this.currentBoss.name}" ƒëang trong tr·∫≠n. Th√™m v√†o danh s√°ch b·ªè qua...`, 'warning');
                    this.rejectedBossIds.add(this.currentBoss.id);
                }
                // Kh√¥ng set this.currentBoss = null ·ªü ƒë√¢y
                setTimeout(() => this.send({ type: 'boss:list' }), 10000); // 10 gi√¢y
            }
        }
        // X·ª≠ l√Ω boss:list nh∆∞ c≈© (gi·ªØ l·∫°i log khi g·ª≠i l·ªánh boss:attack)
        if (data.type === 'boss:list') {
            if (Array.isArray(data.payload)) {
                const bosses = data.payload;
                const now = Date.now();
                const available = bosses.filter(boss => {
                    return !boss.spawnedAt || now >= new Date(boss.spawnedAt).getTime();
                });
                if (available.length === 0) {
                    bosses.forEach(boss => {
                        if (boss.spawnedAt && new Date(boss.spawnedAt).getTime() > now) {
                            const ms = new Date(boss.spawnedAt).getTime() - now;
                            const min = Math.floor(ms / 60000);
                            const sec = Math.floor((ms % 60000) / 1000);
                            this.log(`[Boss] ${boss.name} s·∫Ω h·ªìi sinh sau: ${min} ph√∫t ${sec.toString().padStart(2, '0')} gi√¢y`);
                        }
                    });
                    this.log('[Boss] Kh√¥ng c√≥ boss n√†o xu·∫•t hi·ªán, s·∫Ω ki·ªÉm tra l·∫°i sau...', 'info');
                    return;
                }
                // C√≥ boss xu·∫•t hi·ªán, clear timer n·∫øu c√≥
                if (this.bossListTimeout) {
                    clearTimeout(this.bossListTimeout);
                    this.bossListTimeout = null;
                }
                // T√¨m boss kh√¥ng b·ªã t·ª´ ch·ªëi v√† kh√¥ng ph·∫£i "√Åm D·∫° Huy·ªÅn H·ªìn"
                const bossToAttack = available.find(boss => 
                    !this.rejectedBossIds.has(boss.id) && boss.name !== '√Åm D·∫° Huy·ªÅn H·ªìn'
                ) || available.find(boss => !this.rejectedBossIds.has(boss.id)) || available[0];
                // N·∫øu t·∫•t c·∫£ boss ƒë·ªÅu b·ªã t·ª´ ch·ªëi, reset danh s√°ch sau 5 ph√∫t
                if (available.every(boss => this.rejectedBossIds.has(boss.id))) {
                    this.log(`[Boss] T·∫•t c·∫£ boss ƒë·ªÅu b·ªã t·ª´ ch·ªëi. Reset danh s√°ch sau 5 ph√∫t...`, 'warning');
                    setTimeout(() => {
                        this.rejectedBossIds.clear();
                        this.log(`[Boss] ƒê√£ reset danh s√°ch boss b·ªã t·ª´ ch·ªëi`, 'info');
                    }, 300000); // 5 ph√∫t
                }
                // G·ª≠i l·ªánh ƒë√°nh boss ngay khi nh·∫≠n ƒë∆∞·ª£c boss:list m·ªõi nh·∫•t
                this.log(`[Boss] ƒê√°nh boss: ${bossToAttack.name} (ID: ${bossToAttack.id})`, 'success');
                this.send({ type: 'boss:attack', payload: { bossId: bossToAttack.id } });
                this.currentBoss = bossToAttack;
                this.lastAttackTime = Date.now();
                this.waitingAttack = false;
                if (this.bossListTimeout) {
                    clearTimeout(this.bossListTimeout);
                    this.bossListTimeout = null;
                }
                this.log(`[Boss] ƒê√£ v√†o tr·∫≠n boss, ch·ªù k·∫øt th√∫c...`, 'info');
            }
        } else if (data.type === 'boss:end') {
            this.log('[Boss] Boss ƒë√£ k·∫øt th√∫c!', 'success');
            // Log th√¥ng tin th∆∞·ªüng n·∫øu c√≥
            if (data.payload) {
                const ranking = data.payload.ranking || [];
                const reward = data.payload.reward || {};
                
                // T√¨m v·ªã tr√≠ c·ªßa b·∫°n trong ranking
                const myRank = ranking.findIndex(r => r.userId === this.userId) + 1;
                if (myRank > 0) {
                    this.log(`[Boss] B·∫°n ƒë·ª©ng th·ª© ${myRank} v·ªõi ${ranking[myRank-1].damage.toLocaleString()} damage`, 'success');
                }
                
                // Log th∆∞·ªüng
                if (reward.honor || reward.spiritStone || reward.equipment || reward.item) {
                    this.log('[Boss] Nh·∫≠n th∆∞·ªüng:', 'success');
                    if (reward.honor) this.log(`  - Honor: ${reward.honor}`, 'success');
                    if (reward.spiritStone) this.log(`  - Linh th·∫°ch: ${reward.spiritStone.toLocaleString()}`, 'success');
                    if (reward.equipment) this.log(`  - Trang b·ªã: ${reward.equipment}`, 'success');
                    if (reward.item) this.log(`  - V·∫≠t ph·∫©m: ${reward.item}`, 'success');
                }
            }
            if (this.bossListTimeout) {
                clearTimeout(this.bossListTimeout);
                this.bossListTimeout = null;
            }
            setTimeout(() => this.send({ type: 'boss:list' }), 6000); // 1 ph√∫t
        }
        // L·∫•y userId t·ª´ state n·∫øu ch∆∞a c√≥ (ch·ªâ log 1 l·∫ßn)
        if (data.type === 'state' && data.payload && data.payload.userId) {
            if (!this.userId) {
                this.userId = data.payload.userId;
                this.log(`[Boss] ƒê√£ l·∫•y userId: ${this.userId}`, 'info');
            } else {
                this.userId = data.payload.userId;
            }
        }
        // L∆∞u dame khi nh·∫≠n damage:boss:taken v√† log ngay n·∫øu c√≥ m√°u boss (lu√¥n log n·∫øu c√≥ dame)
        if (data.type === 'damage:boss:taken' && data.payload && typeof data.payload.damageBossTaken === 'number') {
            const damage = data.payload.damageBossTaken;
            const bossName = data.payload.bossName || (this.currentBoss ? this.currentBoss.name : '');
            const currentHp = data.payload.currentHp || (this.currentBoss ? this.currentBoss.currentHp : undefined);
            const maxHp = data.payload.maxHp || (this.currentBoss ? this.currentBoss.maxHp : undefined);
            if (damage > 0) {
                this.lastDamage = damage;
                if (typeof currentHp === 'number' && typeof maxHp === 'number') {
                    this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName} | HP: ${currentHp.toLocaleString()}/${maxHp.toLocaleString()}`);
                } else {
                    this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName}`);
                }
            }
        }
        // Khi nh·∫≠n boss:state th√¨ log dame v√† m√°u boss n·∫øu c√≥ dame l∆∞u l·∫°i (ch·ªâ log khi dame > 0), sau ƒë√≥ reset lastDamage
        if (data.type === 'boss:state' && data.payload) {
            const bossName = data.payload.name || (this.currentBoss ? this.currentBoss.name : 'Boss');
            const currentHp = data.payload.currentHp || data.payload.hp || (this.currentBoss ? this.currentBoss.currentHp : 0);
            const maxHp = data.payload.maxHp || data.payload.hp || (this.currentBoss ? this.currentBoss.maxHp : 0);
            if (this.lastDamage > 0) {
                this.log(`[Boss] Dame: ${this.lastDamage.toLocaleString()} | Boss: ${bossName} | HP: ${currentHp.toLocaleString()}/${maxHp.toLocaleString()}`);
                this.lastDamage = 0;
            }
        }
        // Khi nh·∫≠n boss:state, log t·ªïng s√°t th∆∞∆°ng tr∆∞·ªõc, dame m·ªõi nh·∫•t sau
        if (data.type === 'boss:state' && data.payload && this.userId) {
            const boss = data.payload;
            const bossName = boss.name;
            const currentHp = boss.currentHp;
            const maxHp = boss.maxHp;
            // 1. Log t·ªïng s√°t th∆∞∆°ng c·ªßa b·∫°n
            if (Array.isArray(boss.participants)) {
                const me = boss.participants.find(p => p.userId === this.userId);
                if (me) {
                    const sorted = boss.participants.slice().sort((a, b) => b.totalDamage - a.totalDamage);
                    const myRank = sorted.findIndex(p => p.userId === this.userId) + 1;
                    this.log(`[Boss] T·ªïng s√°t th∆∞∆°ng c·ªßa b·∫°n g√¢y ${me.totalDamage.toLocaleString()} ƒë·ª©ng th·ª© ${myRank}/${boss.participants.length}`);
                }
            }
            // 2. Log dame m·ªõi nh·∫•t c·ªßa b·∫°n
            if (Array.isArray(boss.damageLog)) {
                const myLogs = boss.damageLog.filter(log => log.userId === this.userId);
                if (myLogs.length > 0) {
                    const latest = myLogs[myLogs.length - 1];
                    if (latest._id !== this.lastLoggedDamageId) {
                        this.lastLoggedDamageId = latest._id;
                        this.log(`[Boss] B·∫°n v·ª´a g√¢y ra ${latest.damage.toLocaleString()} dame | Boss: ${bossName} | HP: ${currentHp.toLocaleString()}/${maxHp.toLocaleString()}`);
                    }
                }
            }
        }
        // Th√™m x·ª≠ l√Ω cho message attack ƒë·ªÉ hi·ªÉn th·ªã damage (ch·ªâ log khi dame > 0 v√† kh√°c l·∫ßn tr∆∞·ªõc)
        if (data.type === 'boss:attack' && data.payload) {
            const damage = data.payload.damage;
            const bossName = data.payload.bossName || 'Boss';
            if (damage && damage > 0 && damage !== this.lastDamage) {
                this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName}`);
                this.lastDamage = damage;
            }
        }
        // X·ª≠ l√Ω khi tho√°t kh·ªèi tr·∫≠n Boss th√†nh c√¥ng (gi·ªØ l·∫°i)
        if (data.type === 'boss:leave') {
            this.log(`[Boss] ‚úÖ ƒê√£ tho√°t kh·ªèi tr·∫≠n Boss hi·ªán t·∫°i`, 'success');
            if (this.bossListTimeout) {
                clearTimeout(this.bossListTimeout);
                this.bossListTimeout = null;
            }
            setTimeout(() => this.send({ type: 'boss:list' }), 6000); // 1 ph√∫t
        }
        // Hi·ªÉn th·ªã damage khi c√≥ th√¥ng tin t·ª´ server (lu√¥n log, kh√¥ng c·∫ßn ki·ªÉm tra dame kh√°c l·∫ßn tr∆∞·ªõc)
        if (data.type === 'boss:attack' && data.payload && data.payload.damage) {
            const damage = data.payload.damage;
            const bossName = this.currentBoss ? this.currentBoss.name : 'Boss';
            if (damage > 0) {
                this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName}`);
                this.lastDamage = damage;
            }
        }
        // Hi·ªÉn th·ªã damage khi c√≥ message t·ª´ server v·ªÅ vi·ªác ƒë√°nh boss (gi·ªØ l·∫°i, nh∆∞ng ch·ªâ log khi dame > 0 v√† kh√°c l·∫ßn tr∆∞·ªõc)
        if (data.type === 'system' && data.payload && data.payload.text) {
            const text = data.payload.text;
            const damageMatch = text.match(/(\d+(?:,\d+)*) s√°t th∆∞∆°ng/);
            if (damageMatch) {
                const damage = parseInt(damageMatch[1].replace(/,/g, ''));
                const bossName = this.currentBoss ? this.currentBoss.name : 'Boss';
                if (damage > 0 && damage !== this.lastDamage) {
                    this.log(`[Boss] Dame: ${damage.toLocaleString()} | Boss: ${bossName}`);
                    this.lastDamage = damage;
                }
            }
        }
        // C√≥ th·ªÉ b·ªï sung c√°c x·ª≠ l√Ω kh√°c n·∫øu c·∫ßn
    }

    stop() {
        this.isRunning = false;
        if (this.ws) this.ws.close();
        if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
        if (this.autoListInterval) clearInterval(this.autoListInterval);
    }
}

// ====== ƒêo·∫°n th·ª±c thi m·∫´u ƒë·ªÉ ch·∫°y ƒë·ªôc l·∫≠p ======
if (require.main === module) {
    let cookie = getCookieFromFile();
    if (cookie) {
        const hunter = new WorldBossAutoHunter(cookie.trim());
        hunter.start();
    } else {
        const readline = require('readline');
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        rl.question('Nh·∫≠p cookie (nuxt-session): ', async (cookieInput) => {
            rl.close();
            const hunter = new WorldBossAutoHunter(cookieInput.trim());
            await hunter.start();
        });
    }
}

module.exports = WorldBossAutoHunter; 